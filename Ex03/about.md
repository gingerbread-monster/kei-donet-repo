# 01: Первый пример с использованием Razor Pages
06/10/2020 | C# 8 | ASP.NET Core 3.1
___
### Содержание
1. [Класс Startup](#Класс-Startup)
1. [Добавляем страницу Index](#Добавляем-страницу-Index)
1. [Добавляем простую обработку GET запросов](#Добавляем-простую-обработку-GET-запросов)
1. [Добавляем использование query параметров в GET запросе](#Добавляем-использование-query-параметров-в-GET-запросе)
1. [Простой POST запрос с формой](#Простой-POST-запрос-с-формой)
1. [Логика обработки запроса внутри Razor страницы](#Логика-обработки-запроса-внутри-Razor-страницы)
1. [Полезные ссылки](#Полезные-ссылки)
___
## Класс Startup
В данном примере мы будем использовать функциональность Razor Pages. Для этого добавим сервисы для Razor Pages в коллекцию сервисов. Добавляем следующую строку в метод `ConfigureServices()`:
```cs
services.AddRazorPages();
```

Затем, после `UseRouting()` middleware, добавляем настройку эндпоинтов внутри `UseEndpoints()` middleware:
```cs
app.UseEndpoints(endpoints =>
{
    endpoints.MapRazorPages();
});
```

## Добавляем страницу Index
Добавим в проект папку 'Pages' и создадим в ней новую Razor Page с названием 'Index'. Получим сгенерированный файл *Index.cshtml.cs* с пустым классом `IndexModel`, который будет отвечать за обработку запросов к данной странице:
```cs
public class IndexModel : PageModel
{
    public void OnGet() {}
}
``` 
Также получим сгенерированный файл *Index.cshtml*, который представляет пока что пустую web страницу:
```html+razor
@page
@model Ex01.Pages.IndexModel
@{
}
```
Директива `@page` указывает, что это страница Razor. А директива `@model` - в данном случае это класс привязанного к странице кода `IndexModel`. Согласно условностям класс модели называется по имени страницы плюс суффикс "Model".

## Добавляем простую обработку GET запросов
Теперь добавим простую логику обработки HTTP GET запросов. Пускай на каждый GET запрос на страницу выводитс таблица с коллекцией каких-нибудь данных. Для этого добавим следующий в `OnGet()` метод:
```cs
public string[] People;

public void OnGet()
{
    People = new string[] { "Вася", "Петя", "Олег", "Коля" };
}
```

Инициализируем массив `People` значениями. Далее получаем к нему доступ в самой странице через свойство `Model`:
```html+razor
@page
@model Ex01.Pages.IndexModel
<div>
    <table>
        <tr>
            <td>Номер</td>
            <td>Имя</td>
        </tr>
        @for (int i = 0; i < Model.People?.Length; i++)
        {
            <tr>
                <td>@i</td>
                <td>@Model.People[i]</td>
            </tr>
        }
    </table>
</div>
```
Каждая страница Razor представляет файл с расширением *.cshtml* и содержит смесь кода HTML и конструкций C#. По сути это те же самые представления, что используются в MVC. Но в отличие от MVC с каждой страницей Razor связан файл отделенного кода логики на C#. Например, с файлом *Index.cshtml*, который определяет визуальную часть с помощью синтаксиса Razor + HTML/CSS, связан файл *Index.cshtml.cs*, который определяет логику страницы или ее поведение с помощью кода C#.

Движок Razor при преобразует код страницы содержащий C# и HTML в обычный HTML. Таким образом при GET запросе получим следующую таблицу:

![GET запрос и таблица](../screenshots/ex01/ex01-01.png)

## Добавляем использование query параметров в GET запросе
Для того чтобы воспользоваться встроенным механизмом привязки модели и получить query параметры из GET запроса, достаточно добавить в метод `OnGet()` аргументы для желаемых параметров:
```cs
 public string[] People;

public string message1, message2;

public void OnGet(string msg1, string msg2)
{
    People = new string[] { "Вася", "Петя", "Олег", "Коля" };

    message1 = msg1;
    message2 = msg2;
}
```

Инициализируем переменные `message1` и `message2` пришедшими параметрами чтобы мы могли получить к ним доступ внутри страницы.
Теперь внесёи изменения в код страницы и используем пришедшие query аргументы:
```html+razor
@//...предшествующий код страницы...

<div>
    @if (!(Model.message1 is null))
    {
        <p>Сообщение 1: @Model.message1</p>
    }

    <p>Сообщение 2: @Model.message2</p>
</div>
```

В результате в зависимости от передаваемых в адресной строке параметров мы будем получать подобный резултат:

![GET запрос и query параметры](../screenshots/ex01/ex01-02.png)

## Простой POST запрос с формой
Для обработки POST запросов следует добавить метод `OnPost()` в класс `IndexModel`. Для получения данных формы следует добавить соответствующие принимаемые аргументы в метод `OnPost()`:
```cs
public void OnPost(int? num1, int? num2)
{
    if (num1 is null)
        num1 = default(int);

    if (num2 is null)
        num2 = default(int);

    ViewData["sum"] = num1 + num2;
}
```

Данный метод будет принимать из формы 2 опциональных числовых параметра и складывать их. Результат будет записываться в свойство `ViewData` специально предназначенное для передачи данных в представление.

Добавим HTML код для формы и место для вывода результата сложения:
```html+razor
@//...предшествующий код страницы...

<div>
    <form method="post">
        <input type="number" name="num1" placeholder="first number" />
        <input type="number" name="num2" placeholder="second number" />
        <input type="submit" value="Sum" />
        @Html.AntiForgeryToken()
    </form>

    <label>Sum result = @ViewData["sum"]</label>
</div>
```

Обратите внимание, для того чтобы привязка модели сработала корректно, и мы смогли получить передаваемые параметры в методе `OnPost()`, необходимо чтобы имена параметров в аттрибуте `name` и названия аргументов в `OnPost(int? num1, int? num2)` совпадали.

Результат отправки формы с числами 5 и 8 приведён ниже:

![POST запрос с формой](../screenshots/ex01/ex01-03.png)

Обратите также внимание на то что таблица пуста и не содержит строк. Это произошло из-за того что при исполнении запроса сработал метод `OnPost()` а не `OnGet()` (в котором и происходит инициализация массива `People` значениями). Также пришлось добавить соответствующую проверку на `null` в цикл заполнения таблицы:
```cs
@for (int i = 0; i < Model.People?.Length; i++)
```
## Логика обработки запроса внутри Razor страницы
Во всех примерах выше для определения логики обработки запроса мы использовали класс `IndexModel`, производный от `PageModel`. Однако страница Razor уже сама по себе представляет модель. И мы можем всю логику обработки и свойства модели определить напрямую в странице. Например, изменим страницу *Index.cshtml* следующим образом:
```html+razor
@page

@functions{
    public string[] People;

    public string message1, message2;

    public void OnGet(string msg1, string msg2)
    {
        People = new string[] { "Вася", "Петя", "Олег", "Коля" };

        message1 = msg1;
        message2 = msg2;
    }

    public void OnPost(int? num1, int? num2)
    {
        if (num1 is null)
            num1 = default(int);

        if (num2 is null)
            num2 = default(int);

        ViewData["sum"] = num1 + num2;
    }
}

<div>
    <table>
        <tr>
            <td>Номер</td>
            <td>Имя</td>

@ // ОСТАЛЬНАЯ РАЗМЕТКА ОПРЕДЕЛЕННАЯ РАНЕЕ
```
Что именно изменилось:
* Перенесли всю логику обработки запросов (свойства и методы) из класса `IndexModel` в блок `@functions{}` внутри самой страницы
* Убрали строку `@model Ex01.Pages.IndexModel`
* А сам файл *Index.cshtml.cs* (с классом `IndexModel`) удалили за ненадобностью.

В результате страница будет работать и обрабатывать запросы точно так же как и раньше.

Однако такой подход практически не используется из-за того что логика обработки запросов смешивается с логикой представления данных. Такое обычно не допускается.

## Полезные ссылки
* [Introduction to Razor Pages in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-3.1)
    * [Введение в Razor Pages](https://metanit.com/sharp/aspnet5/29.1.php)